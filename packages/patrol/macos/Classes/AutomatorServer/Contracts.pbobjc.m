// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: contracts.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Contracts.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(DartTestCase);
GPBObjCClassDeclaration(DartTestGroup);
GPBObjCClassDeclaration(NativeView);
GPBObjCClassDeclaration(Notification);
GPBObjCClassDeclaration(Selector);
GPBObjCClassDeclaration(SubmitTestResultsRequest);

#pragma mark - ContractsRoot

@implementation ContractsRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - ContractsRoot_FileDescriptor

static GPBFileDescriptor *ContractsRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"patrol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ListDartTestsResponse

@implementation ListDartTestsResponse

@dynamic hasGroup, group;

typedef struct ListDartTestsResponse__storage_ {
  uint32_t _has_storage_[1];
  DartTestGroup *group;
} ListDartTestsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "group",
        .dataTypeSpecific.clazz = GPBObjCClass(DartTestGroup),
        .number = ListDartTestsResponse_FieldNumber_Group,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ListDartTestsResponse__storage_, group),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListDartTestsResponse class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListDartTestsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DartTestGroup

@implementation DartTestGroup

@dynamic name;
@dynamic testsArray, testsArray_Count;
@dynamic groupsArray, groupsArray_Count;

typedef struct DartTestGroup__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableArray *testsArray;
  NSMutableArray *groupsArray;
} DartTestGroup__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = DartTestGroup_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DartTestGroup__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "testsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DartTestCase),
        .number = DartTestGroup_FieldNumber_TestsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DartTestGroup__storage_, testsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "groupsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(DartTestGroup),
        .number = DartTestGroup_FieldNumber_GroupsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DartTestGroup__storage_, groupsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DartTestGroup class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DartTestGroup__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DartTestCase

@implementation DartTestCase

@dynamic name;

typedef struct DartTestCase__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} DartTestCase__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = DartTestCase_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DartTestCase__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DartTestCase class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DartTestCase__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RunDartTestRequest

@implementation RunDartTestRequest

@dynamic name;

typedef struct RunDartTestRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
} RunDartTestRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = RunDartTestRequest_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RunDartTestRequest__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RunDartTestRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RunDartTestRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RunDartTestResponse

@implementation RunDartTestResponse

@dynamic result;
@dynamic hasDetails, details;

typedef struct RunDartTestResponse__storage_ {
  uint32_t _has_storage_[1];
  RunDartTestResponse_Result result;
  NSString *details;
} RunDartTestResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = RunDartTestResponse_Result_EnumDescriptor,
        .number = RunDartTestResponse_FieldNumber_Result,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RunDartTestResponse__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "details",
        .dataTypeSpecific.clazz = Nil,
        .number = RunDartTestResponse_FieldNumber_Details,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RunDartTestResponse__storage_, details),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RunDartTestResponse class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RunDartTestResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RunDartTestResponse_Result_RawValue(RunDartTestResponse *message) {
  GPBDescriptor *descriptor = [RunDartTestResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RunDartTestResponse_FieldNumber_Result];
  return GPBGetMessageRawEnumField(message, field);
}

void SetRunDartTestResponse_Result_RawValue(RunDartTestResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [RunDartTestResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RunDartTestResponse_FieldNumber_Result];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum RunDartTestResponse_Result

GPBEnumDescriptor *RunDartTestResponse_Result_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000Skipped\000Failure\000";
    static const int32_t values[] = {
        RunDartTestResponse_Result_Success,
        RunDartTestResponse_Result_Skipped,
        RunDartTestResponse_Result_Failure,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RunDartTestResponse_Result)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RunDartTestResponse_Result_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RunDartTestResponse_Result_IsValidValue(int32_t value__) {
  switch (value__) {
    case RunDartTestResponse_Result_Success:
    case RunDartTestResponse_Result_Skipped:
    case RunDartTestResponse_Result_Failure:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ConfigureRequest

@implementation ConfigureRequest

@dynamic findTimeoutMillis;

typedef struct ConfigureRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t findTimeoutMillis;
} ConfigureRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "findTimeoutMillis",
        .dataTypeSpecific.clazz = Nil,
        .number = ConfigureRequest_FieldNumber_FindTimeoutMillis,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConfigureRequest__storage_, findTimeoutMillis),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConfigureRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConfigureRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\021\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpenAppRequest

@implementation OpenAppRequest

@dynamic appId;

typedef struct OpenAppRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *appId;
} OpenAppRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appId",
        .dataTypeSpecific.clazz = Nil,
        .number = OpenAppRequest_FieldNumber_AppId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OpenAppRequest__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpenAppRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OpenAppRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TapOnNotificationRequest

@implementation TapOnNotificationRequest

@dynamic findByOneOfCase;
@dynamic index;
@dynamic selector;

typedef struct TapOnNotificationRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t index;
  Selector *selector;
} TapOnNotificationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = TapOnNotificationRequest_FieldNumber_Index,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TapOnNotificationRequest__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "selector",
        .dataTypeSpecific.clazz = GPBObjCClass(Selector),
        .number = TapOnNotificationRequest_FieldNumber_Selector,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(TapOnNotificationRequest__storage_, selector),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TapOnNotificationRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TapOnNotificationRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "findBy",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void TapOnNotificationRequest_ClearFindByOneOfCase(TapOnNotificationRequest *message) {
  GPBDescriptor *descriptor = [TapOnNotificationRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - Empty

@implementation Empty


typedef struct Empty__storage_ {
  uint32_t _has_storage_[1];
} Empty__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Empty class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(Empty__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OpenQuickSettingsRequest

@implementation OpenQuickSettingsRequest


typedef struct OpenQuickSettingsRequest__storage_ {
  uint32_t _has_storage_[1];
} OpenQuickSettingsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OpenQuickSettingsRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(OpenQuickSettingsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DarkModeRequest

@implementation DarkModeRequest

@dynamic appId;

typedef struct DarkModeRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *appId;
} DarkModeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appId",
        .dataTypeSpecific.clazz = Nil,
        .number = DarkModeRequest_FieldNumber_AppId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DarkModeRequest__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DarkModeRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DarkModeRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNativeViewsRequest

@implementation GetNativeViewsRequest

@dynamic hasSelector, selector;
@dynamic appId;

typedef struct GetNativeViewsRequest__storage_ {
  uint32_t _has_storage_[1];
  Selector *selector;
  NSString *appId;
} GetNativeViewsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "selector",
        .dataTypeSpecific.clazz = GPBObjCClass(Selector),
        .number = GetNativeViewsRequest_FieldNumber_Selector,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetNativeViewsRequest__storage_, selector),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appId",
        .dataTypeSpecific.clazz = Nil,
        .number = GetNativeViewsRequest_FieldNumber_AppId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetNativeViewsRequest__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNativeViewsRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetNativeViewsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNativeViewsResponse

@implementation GetNativeViewsResponse

@dynamic nativeViewsArray, nativeViewsArray_Count;

typedef struct GetNativeViewsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nativeViewsArray;
} GetNativeViewsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nativeViewsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(NativeView),
        .number = GetNativeViewsResponse_FieldNumber_NativeViewsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetNativeViewsResponse__storage_, nativeViewsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNativeViewsResponse class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetNativeViewsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\000nativeViews\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNotificationsRequest

@implementation GetNotificationsRequest


typedef struct GetNotificationsRequest__storage_ {
  uint32_t _has_storage_[1];
} GetNotificationsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNotificationsRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetNotificationsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetNotificationsResponse

@implementation GetNotificationsResponse

@dynamic notificationsArray, notificationsArray_Count;

typedef struct GetNotificationsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *notificationsArray;
} GetNotificationsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "notificationsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(Notification),
        .number = GetNotificationsResponse_FieldNumber_NotificationsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetNotificationsResponse__storage_, notificationsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetNotificationsResponse class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetNotificationsResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TapRequest

@implementation TapRequest

@dynamic hasSelector, selector;
@dynamic appId;

typedef struct TapRequest__storage_ {
  uint32_t _has_storage_[1];
  Selector *selector;
  NSString *appId;
} TapRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "selector",
        .dataTypeSpecific.clazz = GPBObjCClass(Selector),
        .number = TapRequest_FieldNumber_Selector,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TapRequest__storage_, selector),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appId",
        .dataTypeSpecific.clazz = Nil,
        .number = TapRequest_FieldNumber_AppId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TapRequest__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TapRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TapRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EnterTextRequest

@implementation EnterTextRequest

@dynamic findByOneOfCase;
@dynamic data_p;
@dynamic appId;
@dynamic index;
@dynamic selector;
@dynamic showKeyboard;

typedef struct EnterTextRequest__storage_ {
  uint32_t _has_storage_[2];
  uint32_t index;
  NSString *data_p;
  NSString *appId;
  Selector *selector;
} EnterTextRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.clazz = Nil,
        .number = EnterTextRequest_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EnterTextRequest__storage_, data_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appId",
        .dataTypeSpecific.clazz = Nil,
        .number = EnterTextRequest_FieldNumber_AppId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EnterTextRequest__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "index",
        .dataTypeSpecific.clazz = Nil,
        .number = EnterTextRequest_FieldNumber_Index,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(EnterTextRequest__storage_, index),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "selector",
        .dataTypeSpecific.clazz = GPBObjCClass(Selector),
        .number = EnterTextRequest_FieldNumber_Selector,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(EnterTextRequest__storage_, selector),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "showKeyboard",
        .dataTypeSpecific.clazz = Nil,
        .number = EnterTextRequest_FieldNumber_ShowKeyboard,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EnterTextRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EnterTextRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    static const char *oneofs[] = {
      "findBy",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\005\000\005\014\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void EnterTextRequest_ClearFindByOneOfCase(EnterTextRequest *message) {
  GPBDescriptor *descriptor = [EnterTextRequest descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBClearOneof(message, oneof);
}
#pragma mark - SwipeRequest

@implementation SwipeRequest

@dynamic startX;
@dynamic startY;
@dynamic endX;
@dynamic endY;
@dynamic steps;
@dynamic appId;

typedef struct SwipeRequest__storage_ {
  uint32_t _has_storage_[1];
  float startX;
  float startY;
  float endX;
  float endY;
  uint32_t steps;
  NSString *appId;
} SwipeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startX",
        .dataTypeSpecific.clazz = Nil,
        .number = SwipeRequest_FieldNumber_StartX,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SwipeRequest__storage_, startX),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "startY",
        .dataTypeSpecific.clazz = Nil,
        .number = SwipeRequest_FieldNumber_StartY,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SwipeRequest__storage_, startY),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "endX",
        .dataTypeSpecific.clazz = Nil,
        .number = SwipeRequest_FieldNumber_EndX,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SwipeRequest__storage_, endX),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "endY",
        .dataTypeSpecific.clazz = Nil,
        .number = SwipeRequest_FieldNumber_EndY,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SwipeRequest__storage_, endY),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "steps",
        .dataTypeSpecific.clazz = Nil,
        .number = SwipeRequest_FieldNumber_Steps,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SwipeRequest__storage_, steps),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "appId",
        .dataTypeSpecific.clazz = Nil,
        .number = SwipeRequest_FieldNumber_AppId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SwipeRequest__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SwipeRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SwipeRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\006\000\002\006\000\003\004\000\004\004\000\006\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - WaitUntilVisibleRequest

@implementation WaitUntilVisibleRequest

@dynamic hasSelector, selector;
@dynamic appId;

typedef struct WaitUntilVisibleRequest__storage_ {
  uint32_t _has_storage_[1];
  Selector *selector;
  NSString *appId;
} WaitUntilVisibleRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "selector",
        .dataTypeSpecific.clazz = GPBObjCClass(Selector),
        .number = WaitUntilVisibleRequest_FieldNumber_Selector,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(WaitUntilVisibleRequest__storage_, selector),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "appId",
        .dataTypeSpecific.clazz = Nil,
        .number = WaitUntilVisibleRequest_FieldNumber_AppId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(WaitUntilVisibleRequest__storage_, appId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[WaitUntilVisibleRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(WaitUntilVisibleRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HandlePermissionRequest

@implementation HandlePermissionRequest

@dynamic code;

typedef struct HandlePermissionRequest__storage_ {
  uint32_t _has_storage_[1];
  HandlePermissionRequest_Code code;
} HandlePermissionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "code",
        .dataTypeSpecific.enumDescFunc = HandlePermissionRequest_Code_EnumDescriptor,
        .number = HandlePermissionRequest_FieldNumber_Code,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HandlePermissionRequest__storage_, code),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HandlePermissionRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HandlePermissionRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t HandlePermissionRequest_Code_RawValue(HandlePermissionRequest *message) {
  GPBDescriptor *descriptor = [HandlePermissionRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:HandlePermissionRequest_FieldNumber_Code];
  return GPBGetMessageRawEnumField(message, field);
}

void SetHandlePermissionRequest_Code_RawValue(HandlePermissionRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [HandlePermissionRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:HandlePermissionRequest_FieldNumber_Code];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum HandlePermissionRequest_Code

GPBEnumDescriptor *HandlePermissionRequest_Code_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "WhileUsing\000OnlyThisTime\000Denied\000";
    static const int32_t values[] = {
        HandlePermissionRequest_Code_WhileUsing,
        HandlePermissionRequest_Code_OnlyThisTime,
        HandlePermissionRequest_Code_Denied,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(HandlePermissionRequest_Code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:HandlePermissionRequest_Code_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL HandlePermissionRequest_Code_IsValidValue(int32_t value__) {
  switch (value__) {
    case HandlePermissionRequest_Code_WhileUsing:
    case HandlePermissionRequest_Code_OnlyThisTime:
    case HandlePermissionRequest_Code_Denied:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SetLocationAccuracyRequest

@implementation SetLocationAccuracyRequest

@dynamic locationAccuracy;

typedef struct SetLocationAccuracyRequest__storage_ {
  uint32_t _has_storage_[1];
  SetLocationAccuracyRequest_LocationAccuracy locationAccuracy;
} SetLocationAccuracyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "locationAccuracy",
        .dataTypeSpecific.enumDescFunc = SetLocationAccuracyRequest_LocationAccuracy_EnumDescriptor,
        .number = SetLocationAccuracyRequest_FieldNumber_LocationAccuracy,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetLocationAccuracyRequest__storage_, locationAccuracy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetLocationAccuracyRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetLocationAccuracyRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SetLocationAccuracyRequest_LocationAccuracy_RawValue(SetLocationAccuracyRequest *message) {
  GPBDescriptor *descriptor = [SetLocationAccuracyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetLocationAccuracyRequest_FieldNumber_LocationAccuracy];
  return GPBGetMessageRawEnumField(message, field);
}

void SetSetLocationAccuracyRequest_LocationAccuracy_RawValue(SetLocationAccuracyRequest *message, int32_t value) {
  GPBDescriptor *descriptor = [SetLocationAccuracyRequest descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SetLocationAccuracyRequest_FieldNumber_LocationAccuracy];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - Enum SetLocationAccuracyRequest_LocationAccuracy

GPBEnumDescriptor *SetLocationAccuracyRequest_LocationAccuracy_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Coarse\000Fine\000";
    static const int32_t values[] = {
        SetLocationAccuracyRequest_LocationAccuracy_Coarse,
        SetLocationAccuracyRequest_LocationAccuracy_Fine,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SetLocationAccuracyRequest_LocationAccuracy)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SetLocationAccuracyRequest_LocationAccuracy_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SetLocationAccuracyRequest_LocationAccuracy_IsValidValue(int32_t value__) {
  switch (value__) {
    case SetLocationAccuracyRequest_LocationAccuracy_Coarse:
    case SetLocationAccuracyRequest_LocationAccuracy_Fine:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - PermissionDialogVisibleRequest

@implementation PermissionDialogVisibleRequest

@dynamic timeoutMillis;

typedef struct PermissionDialogVisibleRequest__storage_ {
  uint32_t _has_storage_[1];
  uint64_t timeoutMillis;
} PermissionDialogVisibleRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timeoutMillis",
        .dataTypeSpecific.clazz = Nil,
        .number = PermissionDialogVisibleRequest_FieldNumber_TimeoutMillis,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PermissionDialogVisibleRequest__storage_, timeoutMillis),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PermissionDialogVisibleRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PermissionDialogVisibleRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\r\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PermissionDialogVisibleResponse

@implementation PermissionDialogVisibleResponse

@dynamic visible;

typedef struct PermissionDialogVisibleResponse__storage_ {
  uint32_t _has_storage_[1];
} PermissionDialogVisibleResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "visible",
        .dataTypeSpecific.clazz = Nil,
        .number = PermissionDialogVisibleResponse_FieldNumber_Visible,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PermissionDialogVisibleResponse class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PermissionDialogVisibleResponse__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Selector

@implementation Selector

@dynamic hasText, text;
@dynamic hasTextStartsWith, textStartsWith;
@dynamic hasTextContains, textContains;
@dynamic hasClassName_p, className_p;
@dynamic hasContentDescription, contentDescription;
@dynamic hasContentDescriptionStartsWith, contentDescriptionStartsWith;
@dynamic hasContentDescriptionContains, contentDescriptionContains;
@dynamic hasResourceId, resourceId;
@dynamic hasInstance, instance;
@dynamic hasEnabled, enabled;
@dynamic hasFocused, focused;
@dynamic hasPkg, pkg;

typedef struct Selector__storage_ {
  uint32_t _has_storage_[1];
  uint32_t instance;
  NSString *text;
  NSString *textStartsWith;
  NSString *textContains;
  NSString *className_p;
  NSString *contentDescription;
  NSString *contentDescriptionStartsWith;
  NSString *contentDescriptionContains;
  NSString *resourceId;
  NSString *pkg;
} Selector__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_Text,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Selector__storage_, text),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "textStartsWith",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_TextStartsWith,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Selector__storage_, textStartsWith),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "textContains",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_TextContains,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Selector__storage_, textContains),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "className_p",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_ClassName_p,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Selector__storage_, className_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentDescription",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_ContentDescription,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Selector__storage_, contentDescription),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentDescriptionStartsWith",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_ContentDescriptionStartsWith,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Selector__storage_, contentDescriptionStartsWith),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentDescriptionContains",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_ContentDescriptionContains,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Selector__storage_, contentDescriptionContains),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "resourceId",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_ResourceId,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Selector__storage_, resourceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "instance",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_Instance,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Selector__storage_, instance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "enabled",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_Enabled,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "focused",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_Focused,
        .hasIndex = 11,
        .offset = 12,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "pkg",
        .dataTypeSpecific.clazz = Nil,
        .number = Selector_FieldNumber_Pkg,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(Selector__storage_, pkg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Selector class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Selector__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\002\016\000\003\014\000\004\000className\000\005\022\000\006\034\000\007\032\000\010\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NativeView

@implementation NativeView

@dynamic className_p;
@dynamic text;
@dynamic contentDescription;
@dynamic focused;
@dynamic enabled;
@dynamic childCount;
@dynamic resourceName;
@dynamic applicationPackage;
@dynamic childrenArray, childrenArray_Count;

typedef struct NativeView__storage_ {
  uint32_t _has_storage_[1];
  int32_t childCount;
  NSString *className_p;
  NSString *text;
  NSString *contentDescription;
  NSString *resourceName;
  NSString *applicationPackage;
  NSMutableArray *childrenArray;
} NativeView__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "className_p",
        .dataTypeSpecific.clazz = Nil,
        .number = NativeView_FieldNumber_ClassName_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NativeView__storage_, className_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "text",
        .dataTypeSpecific.clazz = Nil,
        .number = NativeView_FieldNumber_Text,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NativeView__storage_, text),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "contentDescription",
        .dataTypeSpecific.clazz = Nil,
        .number = NativeView_FieldNumber_ContentDescription,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NativeView__storage_, contentDescription),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "focused",
        .dataTypeSpecific.clazz = Nil,
        .number = NativeView_FieldNumber_Focused,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "enabled",
        .dataTypeSpecific.clazz = Nil,
        .number = NativeView_FieldNumber_Enabled,
        .hasIndex = 5,
        .offset = 6,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "childCount",
        .dataTypeSpecific.clazz = Nil,
        .number = NativeView_FieldNumber_ChildCount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NativeView__storage_, childCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "resourceName",
        .dataTypeSpecific.clazz = Nil,
        .number = NativeView_FieldNumber_ResourceName,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NativeView__storage_, resourceName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "applicationPackage",
        .dataTypeSpecific.clazz = Nil,
        .number = NativeView_FieldNumber_ApplicationPackage,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NativeView__storage_, applicationPackage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "childrenArray",
        .dataTypeSpecific.clazz = GPBObjCClass(NativeView),
        .number = NativeView_FieldNumber_ChildrenArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NativeView__storage_, childrenArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NativeView class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NativeView__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\000className\000\003\022\000\006\n\000\007\014\000\010\022\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Notification

@implementation Notification

@dynamic hasAppName, appName;
@dynamic title;
@dynamic content;
@dynamic raw;

typedef struct Notification__storage_ {
  uint32_t _has_storage_[1];
  NSString *appName;
  NSString *title;
  NSString *content;
  NSString *raw;
} Notification__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "appName",
        .dataTypeSpecific.clazz = Nil,
        .number = Notification_FieldNumber_AppName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Notification__storage_, appName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "title",
        .dataTypeSpecific.clazz = Nil,
        .number = Notification_FieldNumber_Title,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Notification__storage_, title),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "content",
        .dataTypeSpecific.clazz = Nil,
        .number = Notification_FieldNumber_Content,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Notification__storage_, content),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "raw",
        .dataTypeSpecific.clazz = Nil,
        .number = Notification_FieldNumber_Raw,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Notification__storage_, raw),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Notification class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Notification__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SubmitTestResultsRequest

@implementation SubmitTestResultsRequest

@dynamic results, results_Count;

typedef struct SubmitTestResultsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *results;
} SubmitTestResultsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "results",
        .dataTypeSpecific.clazz = Nil,
        .number = SubmitTestResultsRequest_FieldNumber_Results,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SubmitTestResultsRequest__storage_, results),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SubmitTestResultsRequest class]
                                     rootClass:[ContractsRoot class]
                                          file:ContractsRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SubmitTestResultsRequest__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
